{
  
    
        "post0": {
            "title": "Using molecule images as input?",
            "content": "For some time now I&#39;ve been wondering how much chemistry is necessary to train a model for QSAR. Do we need hand-crafted descriptors, such as ECFP and MACCS fingerprints? Or maybe complex quantum mechanical properties calculated with state-of-the-art software? . On the last post, we used image-like input to train bioactivity classifier using fastai. But what if we tried with REAL images? . First, we will import some libraries, including rdkit to deal with molecules. . Import modules . from rdkit import Chem from collections import Counter from rdkit.Chem import Draw, AllChem from rdkit.Chem.Draw import rdMolDraw2D from rdkit.Chem import rdDepictor import os import numpy as np from PIL import Image, ImageOps from io import BytesIO from fastai.vision.all import * from sklearn.model_selection import train_test_split from tqdm.notebook import tqdm . . Load data . moldf = pd.read_csv(&#39;/home/marcossantana/Downloads/fxa_ic50_processed.csv&#39;,sep=&#39;;&#39;).reset_index(drop=True) . moldf[&#39;filename&#39;] = [f&#39;mols_imgs/mol_{i}.png&#39; for i in moldf.index] . moldf.head() . doc_id standard_value standard_type standard_relation pchembl molregno canonical_smiles chembl_id target_dictionary target_chembl_id l1 l2 l3 confidence_score act processed_smiles filename . 0 3476 | 44.4 | IC50 | = | 7.35 | 192068 | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O | CHEMBL117716 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O | mols_imgs/mol_0.png | . 1 6512 | 180.0 | IC50 | = | 6.75 | 203908 | Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O | CHEMBL337921 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O | mols_imgs/mol_1.png | . 2 6512 | 120.0 | IC50 | = | 6.92 | 204329 | Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O | CHEMBL340500 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O | mols_imgs/mol_2.png | . 3 3476 | 311.0 | IC50 | = | 6.51 | 192044 | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O | CHEMBL117721 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O | mols_imgs/mol_3.png | . 4 3476 | 6.1 | IC50 | = | 8.21 | 191486 | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O | CHEMBL331807 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O | mols_imgs/mol_4.png | . . moldf.shape . (2129, 17) . . Note: Never forget to separate a validation set! . train,valid = train_test_split(moldf,stratify=moldf[&#39;act&#39;],test_size = 0.2) train_idx, valid_idx = train.index, valid.index del train, valid . Save images . Now we need a way to convert our molecules to images. We can use RDKit Draw class for that. I think the API is a quite complex, especially for non-coders. I&#39;ll not explain it in details here. Please, check the official RDKit documentation and this short tutorial about the new drawing code) . def generate_mol_images(mols): &#39;&#39;&#39;Generate images from a collection of molecules&#39;&#39;&#39; mols = list(map(Chem.MolFromSmiles, mols)) print(len(mols)) for i, mol in enumerate(tqdm(mols,total=len(mols))): mol2image(mol, filename=f&#39;mol_{i}.png&#39;) #imgs = torch.stack(list(map(mol2image, mols))) def mol2image(m,filename=&#39;&#39;,save_dir=&#39;mols_imgs&#39;): &#39;&#39;&#39;Draw RDKit molecules as images&#39;&#39;&#39; # print(os.path.join(save_dir,filename)) d2d = rdMolDraw2D.MolDraw2DCairo(400, 400) # or MolDraw2DSVG to get SVGs d2d.drawOptions().bondLineWidth=5 # bondLineWidth (if positive, this overrides the default line width for bonds) d2d.drawOptions().padding=0.05 d2d.DrawMolecule(m) d2d.FinishDrawing() if os.path.exists(save_dir): path = os.path.join(save_dir, filename) d2d.WriteDrawingText(path) else: os.mkdir(save_dir) path = os.path.join(save_dir, filename) d2d.WriteDrawingText(path) . The mol2image function receives as input a molecule and converts it to an image. Briefly, we set a canvas of shape 400 x 400 pixels and the define some drawing options using the drawOptions method; in this example we&#39;ll make the bonds larger (bondLineWidth = 5) and add a little bit of padding (padding = 0.05) to the canvas. This will give us a good baseline to easily draw molecules. You can play around with the drawing options if you wish. . After drawing, we save the images to a folder. Take a look at a sample: . . Now let&#39;s save our images! . generate_mol_images(moldf[&#39;processed_smiles&#39;].values) . 2129 . The ls method allows us to see the saved image files. . path = Path(&#39;mols_imgs&#39;) path.ls() . (#2129) [Path(&#39;mols_imgs/mol_538.png&#39;),Path(&#39;mols_imgs/mol_508.png&#39;),Path(&#39;mols_imgs/mol_1741.png&#39;),Path(&#39;mols_imgs/mol_628.png&#39;),Path(&#39;mols_imgs/mol_265.png&#39;),Path(&#39;mols_imgs/mol_1477.png&#39;),Path(&#39;mols_imgs/mol_90.png&#39;),Path(&#39;mols_imgs/mol_2056.png&#39;),Path(&#39;mols_imgs/mol_1046.png&#39;),Path(&#39;mols_imgs/mol_2099.png&#39;)...] . Datablock . In order to train our model, we first need to create a DataLoaders object containing our training and validation sets. First, we create our datablock, which is basically a blueprint that tells fastai how to get our dependent and independent variables, how to treat them (e.g. are they images, text or tabular? is the dependent variable categorical or continuous?) and some transformations, including resizing the images and applying augmentation methods to them. . d_block = DataBlock(blocks=(ImageBlock(), CategoryBlock()), get_x=ColReader(&#39;filename&#39;), get_y = ColReader(&#39;act&#39;), item_tfms=Resize(256), batch_tfms=Rotate(180),splitter=IndexSplitter(valid_idx)) . The DataBlock API is very handy! We can inspect if our blueprint is alright but using the summary method to try to create a batch of our data. If it fails, we can see in which step. It&#39;s a very nice debugging strategy. . d_block.summary(moldf) . Setting-up type transforms pipelines Collecting items from doc_id standard_value standard_type standard_relation pchembl 0 3476 44.4 IC50 = 7.35 1 6512 180.0 IC50 = 6.75 2 6512 120.0 IC50 = 6.92 3 3476 311.0 IC50 = 6.51 4 3476 6.1 IC50 = 8.21 ... ... ... ... ... ... 2124 109537 1023.0 IC50 = 5.99 2125 109537 3026.0 IC50 = 5.52 2126 109537 8451.0 IC50 = 5.07 2127 109537 5735.0 IC50 = 5.24 2128 109537 3.4 IC50 = 8.47 molregno 0 192068 1 203908 2 204329 3 192044 4 191486 ... ... 2124 2333070 2125 2319885 2126 2333406 2127 2325502 2128 709600 canonical_smiles 0 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O 1 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O 2 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O 3 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O 4 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O ... ... 2124 CC1(C)OCC([C@]2(C)C=C3CC[C@@H]4C(C)(C)[C@H](O)CC[C@@]4(C)[C@@H]3CC2)O1 2125 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)([C@@H](O)CO)C=C3CC[C@@H]2C1(C)C 2126 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(CO)C=C3CC[C@@H]2C1(C)C 2127 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(O)CC=C3CC[C@@H]2C1(C)C 2128 CN1CCc2nc(C(=O)N[C@@H]3C[C@@H](C(=O)N(C)C)CC[C@@H]3NC(=O)C(=O)Nc3ccc(Cl)cn3)sc2C1 chembl_id target_dictionary target_chembl_id l1 l2 0 CHEMBL117716 194 CHEMBL244 Enzyme Protease 1 CHEMBL337921 194 CHEMBL244 Enzyme Protease 2 CHEMBL340500 194 CHEMBL244 Enzyme Protease 3 CHEMBL117721 194 CHEMBL244 Enzyme Protease 4 CHEMBL331807 194 CHEMBL244 Enzyme Protease ... ... ... ... ... ... 2124 CHEMBL4293622 194 CHEMBL244 Enzyme Protease 2125 CHEMBL4280434 194 CHEMBL244 Enzyme Protease 2126 CHEMBL4293958 194 CHEMBL244 Enzyme Protease 2127 CHEMBL4286054 194 CHEMBL244 Enzyme Protease 2128 CHEMBL1269025 194 CHEMBL244 Enzyme Protease l3 confidence_score act 0 Serine protease 8 Active 1 Serine protease 8 Active 2 Serine protease 8 Active 3 Serine protease 8 Active 4 Serine protease 8 Active ... ... ... ... 2124 Serine protease 9 Inactive 2125 Serine protease 9 Inactive 2126 Serine protease 9 Inactive 2127 Serine protease 9 Inactive 2128 Serine protease 9 Active processed_smiles 0 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O 1 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O 2 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O 3 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O 4 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O ... ... 2124 CC1(C)OCC([C@]2(C)C=C3CC[C@@H]4C(C)(C)[C@H](O)CC[C@@]4(C)[C@@H]3CC2)O1 2125 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)([C@@H](O)CO)C=C3CC[C@@H]2C1(C)C 2126 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(CO)C=C3CC[C@@H]2C1(C)C 2127 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(O)CC=C3CC[C@@H]2C1(C)C 2128 CN1CCc2nc(C(=O)N[C@@H]3C[C@@H](C(=O)N(C)C)CC[C@@H]3NC(=O)C(=O)Nc3ccc(Cl)cn3)sc2C1 filename 0 mols_imgs/mol_0.png 1 mols_imgs/mol_1.png 2 mols_imgs/mol_2.png 3 mols_imgs/mol_3.png 4 mols_imgs/mol_4.png ... ... 2124 mols_imgs/mol_2124.png 2125 mols_imgs/mol_2125.png 2126 mols_imgs/mol_2126.png 2127 mols_imgs/mol_2127.png 2128 mols_imgs/mol_2128.png [2129 rows x 17 columns] Found 2129 items 2 datasets of sizes 1703,426 Setting up Pipeline: ColReader -- {&#39;cols&#39;: &#39;filename&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; PILBase.create Setting up Pipeline: ColReader -- {&#39;cols&#39;: &#39;act&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; Categorize -- {&#39;vocab&#39;: None, &#39;sort&#39;: True, &#39;add_na&#39;: False} Building one sample Pipeline: ColReader -- {&#39;cols&#39;: &#39;filename&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; PILBase.create starting from doc_id 6512 standard_value 120 standard_type IC50 standard_relation = pchembl 6.92 molregno 204329 canonical_smiles Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O chembl_id CHEMBL340500 target_dictionary 194 target_chembl_id CHEMBL244 l1 Enzyme l2 Protease l3 Serine protease confidence_score 8 act Active processed_smiles Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O filename mols_imgs/mol_2.png Name: 2, dtype: object applying ColReader -- {&#39;cols&#39;: &#39;filename&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} gives mols_imgs/mol_2.png applying PILBase.create gives PILImage mode=RGB size=400x400 Pipeline: ColReader -- {&#39;cols&#39;: &#39;act&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; Categorize -- {&#39;vocab&#39;: None, &#39;sort&#39;: True, &#39;add_na&#39;: False} starting from doc_id 6512 standard_value 120 standard_type IC50 standard_relation = pchembl 6.92 molregno 204329 canonical_smiles Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O chembl_id CHEMBL340500 target_dictionary 194 target_chembl_id CHEMBL244 l1 Enzyme l2 Protease l3 Serine protease confidence_score 8 act Active processed_smiles Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O filename mols_imgs/mol_2.png Name: 2, dtype: object applying ColReader -- {&#39;cols&#39;: &#39;act&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} gives Active applying Categorize -- {&#39;vocab&#39;: None, &#39;sort&#39;: True, &#39;add_na&#39;: False} gives TensorCategory(0) Final sample: (PILImage mode=RGB size=400x400, TensorCategory(0)) Collecting items from doc_id standard_value standard_type standard_relation pchembl 0 3476 44.4 IC50 = 7.35 1 6512 180.0 IC50 = 6.75 2 6512 120.0 IC50 = 6.92 3 3476 311.0 IC50 = 6.51 4 3476 6.1 IC50 = 8.21 ... ... ... ... ... ... 2124 109537 1023.0 IC50 = 5.99 2125 109537 3026.0 IC50 = 5.52 2126 109537 8451.0 IC50 = 5.07 2127 109537 5735.0 IC50 = 5.24 2128 109537 3.4 IC50 = 8.47 molregno 0 192068 1 203908 2 204329 3 192044 4 191486 ... ... 2124 2333070 2125 2319885 2126 2333406 2127 2325502 2128 709600 canonical_smiles 0 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O 1 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O 2 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O 3 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O 4 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O ... ... 2124 CC1(C)OCC([C@]2(C)C=C3CC[C@@H]4C(C)(C)[C@H](O)CC[C@@]4(C)[C@@H]3CC2)O1 2125 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)([C@@H](O)CO)C=C3CC[C@@H]2C1(C)C 2126 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(CO)C=C3CC[C@@H]2C1(C)C 2127 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(O)CC=C3CC[C@@H]2C1(C)C 2128 CN1CCc2nc(C(=O)N[C@@H]3C[C@@H](C(=O)N(C)C)CC[C@@H]3NC(=O)C(=O)Nc3ccc(Cl)cn3)sc2C1 chembl_id target_dictionary target_chembl_id l1 l2 0 CHEMBL117716 194 CHEMBL244 Enzyme Protease 1 CHEMBL337921 194 CHEMBL244 Enzyme Protease 2 CHEMBL340500 194 CHEMBL244 Enzyme Protease 3 CHEMBL117721 194 CHEMBL244 Enzyme Protease 4 CHEMBL331807 194 CHEMBL244 Enzyme Protease ... ... ... ... ... ... 2124 CHEMBL4293622 194 CHEMBL244 Enzyme Protease 2125 CHEMBL4280434 194 CHEMBL244 Enzyme Protease 2126 CHEMBL4293958 194 CHEMBL244 Enzyme Protease 2127 CHEMBL4286054 194 CHEMBL244 Enzyme Protease 2128 CHEMBL1269025 194 CHEMBL244 Enzyme Protease l3 confidence_score act 0 Serine protease 8 Active 1 Serine protease 8 Active 2 Serine protease 8 Active 3 Serine protease 8 Active 4 Serine protease 8 Active ... ... ... ... 2124 Serine protease 9 Inactive 2125 Serine protease 9 Inactive 2126 Serine protease 9 Inactive 2127 Serine protease 9 Inactive 2128 Serine protease 9 Active processed_smiles 0 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc3ccccc3n2)NS(=O)(=O)Cc2ccccc2)C1O 1 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1-n1ccccc1=O 2 Cc1cc(NC(=O)Cc2ccc3[nH]c(-c4ccc(Cl)s4)nc3c2)ccc1N1CCOCC1=O 3 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CNC(=O)c2cnccn2)NS(=O)(=O)Cc2ccccc2)C1O 4 N=C(N)N1CCC[C@H](NC(=O)CNC(=O)[C@@H](CCNC(=O)c2ccc(O)nc2)NS(=O)(=O)Cc2ccccc2)C1O ... ... 2124 CC1(C)OCC([C@]2(C)C=C3CC[C@@H]4C(C)(C)[C@H](O)CC[C@@]4(C)[C@@H]3CC2)O1 2125 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)([C@@H](O)CO)C=C3CC[C@@H]2C1(C)C 2126 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(CO)C=C3CC[C@@H]2C1(C)C 2127 CC(=O)O[C@@H]1CC[C@@]2(C)[C@@H]3CC[C@](C)(O)CC=C3CC[C@@H]2C1(C)C 2128 CN1CCc2nc(C(=O)N[C@@H]3C[C@@H](C(=O)N(C)C)CC[C@@H]3NC(=O)C(=O)Nc3ccc(Cl)cn3)sc2C1 filename 0 mols_imgs/mol_0.png 1 mols_imgs/mol_1.png 2 mols_imgs/mol_2.png 3 mols_imgs/mol_3.png 4 mols_imgs/mol_4.png ... ... 2124 mols_imgs/mol_2124.png 2125 mols_imgs/mol_2125.png 2126 mols_imgs/mol_2126.png 2127 mols_imgs/mol_2127.png 2128 mols_imgs/mol_2128.png [2129 rows x 17 columns] Found 2129 items 2 datasets of sizes 1703,426 Setting up Pipeline: ColReader -- {&#39;cols&#39;: &#39;filename&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; PILBase.create Setting up Pipeline: ColReader -- {&#39;cols&#39;: &#39;act&#39;, &#39;pref&#39;: &#39;&#39;, &#39;suff&#39;: &#39;&#39;, &#39;label_delim&#39;: None} -&gt; Categorize -- {&#39;vocab&#39;: None, &#39;sort&#39;: True, &#39;add_na&#39;: False} Setting up after_item: Pipeline: Resize -- {&#39;size&#39;: (256, 256), &#39;method&#39;: &#39;crop&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;resamples&#39;: (2, 0), &#39;p&#39;: 1.0} -&gt; ToTensor Setting up before_batch: Pipeline: Setting up after_batch: Pipeline: IntToFloatTensor -- {&#39;div&#39;: 255.0, &#39;div_mask&#39;: 1} -&gt; Rotate -- {&#39;size&#39;: None, &#39;mode&#39;: &#39;bilinear&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;mode_mask&#39;: &#39;nearest&#39;, &#39;align_corners&#39;: True, &#39;p&#39;: 1.0} Building one batch Applying item_tfms to the first sample: Pipeline: Resize -- {&#39;size&#39;: (256, 256), &#39;method&#39;: &#39;crop&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;resamples&#39;: (2, 0), &#39;p&#39;: 1.0} -&gt; ToTensor starting from (PILImage mode=RGB size=400x400, TensorCategory(0)) applying Resize -- {&#39;size&#39;: (256, 256), &#39;method&#39;: &#39;crop&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;resamples&#39;: (2, 0), &#39;p&#39;: 1.0} gives (PILImage mode=RGB size=256x256, TensorCategory(0)) applying ToTensor gives (TensorImage of size 3x256x256, TensorCategory(0)) Adding the next 3 samples No before_batch transform to apply Collating items in a batch Applying batch_tfms to the batch built Pipeline: IntToFloatTensor -- {&#39;div&#39;: 255.0, &#39;div_mask&#39;: 1} -&gt; Rotate -- {&#39;size&#39;: None, &#39;mode&#39;: &#39;bilinear&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;mode_mask&#39;: &#39;nearest&#39;, &#39;align_corners&#39;: True, &#39;p&#39;: 1.0} starting from (TensorImage of size 4x3x256x256, TensorCategory([0, 0, 0, 0], device=&#39;cuda:0&#39;)) applying IntToFloatTensor -- {&#39;div&#39;: 255.0, &#39;div_mask&#39;: 1} gives (TensorImage of size 4x3x256x256, TensorCategory([0, 0, 0, 0], device=&#39;cuda:0&#39;)) applying Rotate -- {&#39;size&#39;: None, &#39;mode&#39;: &#39;bilinear&#39;, &#39;pad_mode&#39;: &#39;reflection&#39;, &#39;mode_mask&#39;: &#39;nearest&#39;, &#39;align_corners&#39;: True, &#39;p&#39;: 1.0} gives (TensorImage of size 4x3x256x256, TensorCategory([0, 0, 0, 0], device=&#39;cuda:0&#39;)) . . No errors? Nice! . Now we can create our dataloaders. . dls = d_block.dataloaders(moldf,bs=32) . dls.show_batch(max_n=4) . Train model . learn = cnn_learner(dls, resnet34, metrics=MatthewsCorrCoef()) . learn.fine_tune(10,base_lr = 5e-4, freeze_epochs=5) . epoch train_loss valid_loss matthews_corrcoef time . 0 | 1.279663 | 0.927331 | 0.156844 | 00:20 | . 1 | 1.133440 | 0.756082 | 0.219890 | 00:19 | . 2 | 1.048430 | 0.702097 | 0.249759 | 00:19 | . 3 | 0.950931 | 0.667921 | 0.327793 | 00:19 | . 4 | 0.885842 | 0.627575 | 0.313518 | 00:18 | . epoch train_loss valid_loss matthews_corrcoef time . 0 | 0.798137 | 0.593731 | 0.372278 | 00:26 | . 1 | 0.741893 | 0.603974 | 0.332780 | 00:26 | . 2 | 0.706047 | 0.553811 | 0.410596 | 00:26 | . 3 | 0.661693 | 0.566272 | 0.448788 | 00:26 | . 4 | 0.626662 | 0.556986 | 0.485671 | 00:26 | . 5 | 0.585711 | 0.572504 | 0.400680 | 00:26 | . 6 | 0.559231 | 0.550696 | 0.504990 | 00:25 | . 7 | 0.548869 | 0.506300 | 0.508802 | 00:26 | . 8 | 0.508134 | 0.506491 | 0.496422 | 00:25 | . 9 | 0.481029 | 0.506984 | 0.485368 | 00:25 | . . The matthew&#39;s correlation coefficient is ~0.50. Not bad at all! . learn.save(&#39;fit1&#39;) . Path(&#39;models/fit1.pth&#39;) . learn.export() . Interpretation . interp = ClassificationInterpretation.from_learner(learn) . interp.plot_confusion_matrix() . As we can see, it is possible to train a model using only images and get a decent MCC. We didn&#39;t even optimize the model or try different data augmentation methods. . I wonder how the model is actually making a prediction. Is it focusing on specific chemical groups? Can we apply interpretation tools used in computer vision? Those are interesting questions that we might take a look in future posts! . Do you have any ideas about possible improvements? Please, let me know! . Fin .",
            "url": "https://marcossantanaioc.github.io/fiocruzcheminformatics/jupyter/2020/12/14/second.html",
            "relUrl": "/jupyter/2020/12/14/second.html",
            "date": " • Dec 14, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "How much chemistry to be useful?",
            "content": "from rdkit.Chem import MolFromSmiles, MolToSmiles from fastai.vision.all import * from rdkit.Chem import AllChem from rdkit import Chem import numpy as np import pandas as pd import IPython.display from PIL import Image . . Hi! This is will be the first post from my new blog. I hope you guys enjoy it. . I&#39;m doing the Fast.AI course and I decided to try solve some problems from my field of research (Cheminformatics) using the fastai package. In this blog, I will try to follow the chapters from the Deep Learning for Coders with fastai &amp; Pytorch. For instance, this notebook was inspired by chapter 2 (the notebook version can be found here) . Let&#39;s begin! . So, what are we going to do? . In this notebook we will try to solve a quantitative structure-activity relationship QSAR problem. What does this mean? Well, QSAR is a major aspect of Cheminformatics. The goal of QSAR is to find useful information in chemical and biological data and use this information for inference on new data. For example, we might want to predict if a molecule is active on a particular biological target. We could start with a dataset of experimentally measured bioactivities (e.g. $IC_{50}$ values, inhibition constants etc) and train a model for bioactivity prediction. This model can be used to predict the bioactivity of other molecules of interest. By using QSAR, BigPharma and research groups can generate new hypothesis much faster and cheaper than testing a bunch of molecules in vitro. . Traditionally, machine learning methods such as random forest, support vector machines and gradient boosting dominate the field. That&#39;s because these classical methods usually give very good results for a range of datasets and are quite easy to train. Until recently, researchers did not apply deep learning in large scale to bioactivity prediction. When they did, it was usually in the form of fully connected neural with just 2-5 layers. However, the last 5 years saw a BOOM in the number of publications using deep learning in very interesting ways! For example, recurrent neural networks are being applied to generate molecules, convnets are showing SOTA performance on binding affinity and pose prediction and multi-task learning was used successfully to win a Kaggle competition for bioactivity prediction! . The most common type of data for QSAR is tabular. Researchers usually calculate many chemical features to describe a collection of molecules. As an example, one of the most common consists in a binary vector indicating the presence/absence of chemical groups in a molecule. We can then use this fingerprint to train a macihine learning model for bioactivity prediction. . In this notebook we will use a different strategy. Instead of calculating a bunch of vectors, we&#39;ll convert each molecule to an image and feed that input to a neural network! As Jeremy said in the book: . Another point to consider is that although your problem might not look like a computer vision problem, it might be possible with a little imagination to turn it into one. For instance, if what you are trying to classify are sounds, you might try converting the sounds into images of their acoustic waveforms and then training a model on those images. . Let&#39;s try that! . How can we convert molecules to images? . In reality, we are not going to convert molecules to images of molecules. What we actually need is a way to represent molecules the same way as images. That way consists of using arrays. For example, an image can be represented as 3D array of shape $(W, H, C)$, where $W$ is the width, $H$ is the height and $C$ is the number of channels. If we could do that to molecules, then it would be straightforward to use it as input to a model. . There are many ways to do that, but we are going to use one that I think is very interesting. In 2017, Garrett B. Goh, Charles Siegel, Abhinav Vishnu, Nathan O. Hodas and Nathan Baker published a preprint showing that machine learning models actually don&#39;t need to know much about chemistry or biology to make a prediction! . In their original manuscript, the authors called their model Chemception and showed that using very, very simple image-like inputs it was possible to achieve SOTA performance on some public datasets. That&#39;s quite an achievement! Until yesterday, the cheminformatics community was using handcrafted features and now it seems we don&#39;t even need to tell many things about molecules to train a predictive model! . As the author mentioned in the preprint: . In addition, it should be emphasized that no additional source of chemistry-inspired features or inputs, such as molecular descriptors or fingerprints were used in training the model. This means that Chemception was not explicitly provided with even the most basic chemical concepts like “valency” or “periodicity”. . This means that Chemception had to learn A LOT about chemistry from scratch, using only not very informative inputs (to humans, at least)! . I really find this amazing! . Just to clarify:I&#39;m not saying the model would be useful in real settings. But it is quite amazing to see a good performance without using elaborate chemical descriptors. . The Chemception model is a convolutional neural network for QSAR tasks. An overview of their method is shown below: . . Load data . mols = pd.read_csv(&#39;/home/marcossantana/Documentos/GitHub/fiocruzcheminformatics/_data/fxa_ic50_processed.csv&#39;,sep=&#39;;&#39;) . mols.head(2) . doc_id standard_value standard_type standard_relation pchembl molregno canonical_smiles chembl_id target_dictionary target_chembl_id l1 l2 l3 confidence_score act processed_smiles is_valid . 0 47181 | 1.5 | IC50 | = | 8.82 | 459679 | COc1ccc(NC(=O)c2ccc(C(=N)N(C)C)cc2)c(C(=O)Nc2ccc(Cl)cn2)c1 | CHEMBL512351 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 8 | Active | COc1ccc(NC(=O)c2ccc(C(=N)N(C)C)cc2)c(C(=O)Nc2ccc(Cl)cn2)c1 | False | . 1 30088 | 29000.0 | IC50 | = | 4.54 | 655811 | Cc1ccc(Oc2nc(Oc3cccc(C(=N)N)c3)c(F)c(NC(C)CCc3ccccc3)c2F)c(C(=O)O)c1 | CHEMBL193933 | 194 | CHEMBL244 | Enzyme | Protease | Serine protease | 9 | Inactive | Cc1ccc(Oc2nc(Oc3cccc(C(=N)N)c3)c(F)c(NC(C)CCc3ccccc3)c2F)c(C(=O)O)c1 | False | . The chemcepterize_mol function below will take care of converting the molecules SMILES strings (a one-line representation of the chemical structure) to the image-like format that we want. . Our workflow will go like this: first we define an embedding dimension and a resolution. You can think of this is a black canvas where the structures will be plotted and each atom will have a resolution consisting of how many pixels will be used to represent it. The dimensions of the canvas will be given by: . $$DIM = frac{EMBED*2}{RES}$$ . where $EMBED$ is the embedding size and $RES$ the resolution . The next step consists of calculating some basic chemical information from the structure, such as bond order, charges, atomic numbers and the hybridization states. This information will be converted into a matrix of shape $(P, DIM, DIM)$, where $P$ is the number of properties or channels in the image (in this case we will use 3) and $DIM$ is the dimension of the canvas. . The properties we will calculated are shown in the figure below from the original manuscript. . . def chemcepterize_mol(mol, embed=20.0, res=0.5): dims = int(embed*2/res) #print(dims) #print(mol) #print(&quot;,,,,,,,,,,,,,,,,,,,,,,&quot;) cmol = Chem.Mol(mol.ToBinary()) #print(cmol) #print(&quot;,,,,,,,,,,,,,,,,,,,,,,&quot;) cmol.ComputeGasteigerCharges() AllChem.Compute2DCoords(cmol) coords = cmol.GetConformer(0).GetPositions() #print(coords) #print(&quot;,,,,,,,,,,,,,,,,,,,,,,&quot;) vect = np.zeros((dims+2,dims+2,4)) # I added 2 pixels on to height and width because this function sometimes does not work if the molecule is too big. #Bonds first for i,bond in enumerate(mol.GetBonds()): bondorder = bond.GetBondTypeAsDouble() bidx = bond.GetBeginAtomIdx() eidx = bond.GetEndAtomIdx() bcoords = coords[bidx] ecoords = coords[eidx] frac = np.linspace(0,1,int(1/res*2)) # for f in frac: c = (f*bcoords + (1-f)*ecoords) idx = int(round((c[0] + embed)/res)) idy = int(round((c[1]+ embed)/res)) #Save in the vector first channel vect[ idx , idy ,0] = bondorder #Atom Layers for i,atom in enumerate(cmol.GetAtoms()): idx = int(round((coords[i][0] + embed)/res)) idy = int(round((coords[i][1]+ embed)/res)) #Atomic number vect[ idx , idy, 1] = atom.GetAtomicNum() #Hybridization hyptype = atom.GetHybridization().real vect[ idx , idy, 2] = hyptype #Gasteiger Charges charge = atom.GetProp(&quot;_GasteigerCharge&quot;) vect[ idx , idy, 3] = charge return Tensor(vect[:, :, :3].T) # We will omit the last dimension just to fit our fastai models. But you can also adapt the architeture to deal with 4 or more channels. . . . Note: an embedding of 32 will give a 128 x 128 canvas. We can use this correlation to generate images of any size. (224 * 32)/128. . First, we will create a column called mol that maps our molecular structures to rdkit.Chem.rdchem.Mol objects. This is essential because we are going to use Rdkit to calculate everything and rdkit.Chem.rdchem.Mol has a bunch of nice functionalities to work with molecular graphs. . mol= MolFromSmiles(&#39;c1ccccc1&#39;) # A rdkit.Chem.rdchem.Mol object representing benzene type(mol) . rdkit.Chem.rdchem.Mol . mols[&#39;mol&#39;] = mols[&#39;processed_smiles&#39;].apply(MolFromSmiles) . Now we are going to vectorize our molecules and transform them to image-like matrices.But first, let&#39;s test our function. . def vectorize(mol, embed, res): return chemcepterize_mol(mol, embed=embed, res=res) . v = vectorize(mols[&quot;mol&quot;][0],embed=56, res=0.5).T.numpy() . Ok, now let&#39;s see what that does! . As you can see, the image is mostly black space and the molecule is just a tiny, tiny part of it (shown in red). The black spaces have no chemical information at all! That&#39;s why the authors said Chemception had to learn everything from scratch! . plt.show(print(v.shape)) plt.imshow(v) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . (226, 226, 3) . &lt;matplotlib.image.AxesImage at 0x7fac6c69b590&gt; . We can make bigger molecules by reducing the embedding size. But beware that will also reduce the total image size. . larger_img = vectorize(mols[&quot;mol&quot;][0],embed=16, res=0.5).T.numpy() . plt.show(print((larger_img.shape))) plt.imshow(larger_img) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . (66, 66, 3) . &lt;matplotlib.image.AxesImage at 0x7fac6c601150&gt; . mols[&quot;molimage&quot;] = mols[&quot;mol&quot;].apply(partial(vectorize, embed=32, res=0.25)) . plt.imshow(mols[&quot;molimage&quot;][0].T.numpy()) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . &lt;matplotlib.image.AxesImage at 0x7fac6c51ce90&gt; . Training our model . Now that we know how to convert the molecules to the desired format, we are ready to train a model using fastai! In order to do that, we need to define three things . 1) How to split data . First, let&#39;s define how to split our data into training and validation sets. Luckly, our dataset comes with a column called &quot;is_valid&quot; showing which molecules should be used for validation and training. Therefore, we will use the ColSplitter class from fastai to get the indeces. We could also do a random split here or any kind at all. Fastai is very flexible! . splits = ColSplitter(&#39;is_valid&#39;)(mols) splits . ((#1703) [0,1,2,3,4,5,6,7,8,9...], (#426) [1703,1704,1705,1706,1707,1708,1709,1710,1711,1712...]) . 2) Define how to get the items . We need to tell fastai how to get the items that we&#39;ll feed to our model. In this case, we will use the images we created and stored in the &quot;molimage&quot; column of our dataframe. . x_tfms = ColReader(&#39;molimage&#39;) . 3) Define the targets . Now we need to tell fastai where are our targets. In this case, our targets are in the column &quot;act&quot;, showing the bioactivity of each molecule. We will also tell fastai to treat the values of this column as categories, which will be used to train a classification model. . y_tfms = [ColReader(&#39;act&#39;),Categorize] . The fastai book uses the DataBlock functionality to create the dataloaders at Chapter 2 and Jeremy says that we actually need four things . What kind of data to work with; | How to get the items; | How to label these items; | How to create a validation set. | But since we are using a custom data type, we&#39;ll skip the step defining the kind of data. . Create dataset . Now we can create our dataset: . mol_dataset = Datasets(mols,[x_tfms,y_tfms], splits=splits) . x,y = mol_dataset[0] x.shape,y . . (torch.Size([3, 258, 258]), TensorCategory(0)) . Create dataloaders . dls = mol_dataset.dataloaders(batch_size=8) . Let&#39;s inspect one batch to see if everything is already: . x,y = dls.one_batch() . x,y . (tensor([[[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]], [[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]], [[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]], ..., [[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]], [[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]], [[[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]], [[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]]], device=&#39;cuda:0&#39;), TensorCategory([0, 0, 1, 1, 0, 1, 1, 0], device=&#39;cuda:0&#39;)) . . It seems everything is in order. Alright! Let&#39;s train this beast! . Fit . metrics = [Recall(pos_label=1),Recall(pos_label = 0), Precision(pos_label = 0), MatthewsCorrCoef()] . learn = cnn_learner(dls, resnet18, metrics=metrics,ps=0.25) . Downloading: &#34;https://download.pytorch.org/models/resnet18-5c106cde.pth&#34; to /home/marcossantana/.cache/torch/hub/checkpoints/resnet18-5c106cde.pth . . . Note: We are going to use Restnet18 instead of the original Inception architeture. . learn.fine_tune(10) . epoch train_loss valid_loss recall_score recall_score precision_score matthews_corrcoef time . 0 | 1.108745 | 1.240608 | 0.331169 | 0.716912 | 0.654362 | 0.050385 | 00:15 | . epoch train_loss valid_loss recall_score recall_score precision_score matthews_corrcoef time . 0 | 0.754158 | 0.685205 | 0.292208 | 0.897059 | 0.691218 | 0.241307 | 00:18 | . 1 | 0.698066 | 0.897160 | 0.201299 | 0.786765 | 0.635015 | -0.014106 | 00:18 | . 2 | 0.630345 | 0.794150 | 0.396104 | 0.750000 | 0.686869 | 0.152768 | 00:18 | . 3 | 0.607187 | 0.601677 | 0.512987 | 0.794118 | 0.742268 | 0.317116 | 00:18 | . 4 | 0.556304 | 0.543766 | 0.538961 | 0.830882 | 0.760943 | 0.386714 | 00:19 | . 5 | 0.392019 | 0.590917 | 0.558442 | 0.849265 | 0.772575 | 0.428208 | 00:18 | . 6 | 0.336817 | 0.561924 | 0.487013 | 0.882353 | 0.752351 | 0.409180 | 00:19 | . 7 | 0.271662 | 0.635271 | 0.461039 | 0.882353 | 0.743034 | 0.385314 | 00:19 | . 8 | 0.192005 | 0.622967 | 0.577922 | 0.834559 | 0.777397 | 0.426781 | 00:19 | . 9 | 0.189609 | 0.632492 | 0.636364 | 0.819853 | 0.799283 | 0.461058 | 00:18 | . It seems everything went pretty well! In addition, the Matthew&#39;s correlation coefficient is quite decent (~0.46). . Interpretation . interp = ClassificationInterpretation.from_learner(learn) . interp.plot_confusion_matrix() . The performance is pretty decent, if without any kind of data augmentation and hyperparameter optimization. . Let&#39;s try with a little bit of data augmentation. . In the original paper, the authors used random rotations of the images. Why is that? Well, since most of the image is empty space, if we distort it even a little bit, by cropping or squishing, it might completly change the molecule represented. Rotating the image is a solution to the data augmentation problem because in this particular case it won&#39;t change the meaning of our images. . dls = mol_dataset.dataloaders(batch_size=8,after_batch=Rotate(max_deg=180)) . learn = cnn_learner(dls, resnet18, metrics=metrics,ps=0.25) . learn.fine_tune(10) . epoch train_loss valid_loss recall_score recall_score precision_score matthews_corrcoef time . 0 | 1.085553 | 0.814067 | 0.428571 | 0.746324 | 0.697595 | 0.180596 | 00:13 | . epoch train_loss valid_loss recall_score recall_score precision_score matthews_corrcoef time . 0 | 0.740874 | 0.696819 | 0.500000 | 0.742647 | 0.724014 | 0.245222 | 00:18 | . 1 | 0.703036 | 0.758111 | 0.461039 | 0.720588 | 0.702509 | 0.183554 | 00:19 | . 2 | 0.653901 | 0.586844 | 0.383117 | 0.867647 | 0.712991 | 0.289424 | 00:18 | . 3 | 0.637761 | 0.676066 | 0.272727 | 0.794118 | 0.658537 | 0.076307 | 00:19 | . 4 | 0.537117 | 0.690890 | 0.435065 | 0.768382 | 0.706081 | 0.212265 | 00:18 | . 5 | 0.483605 | 0.649515 | 0.448052 | 0.860294 | 0.733542 | 0.341583 | 00:19 | . 6 | 0.348445 | 0.609656 | 0.500000 | 0.867647 | 0.753994 | 0.400096 | 00:19 | . 7 | 0.269874 | 0.642070 | 0.571429 | 0.827206 | 0.773196 | 0.411629 | 00:18 | . 8 | 0.203648 | 0.646935 | 0.506494 | 0.871324 | 0.757188 | 0.411164 | 00:19 | . 9 | 0.198849 | 0.674963 | 0.506494 | 0.871324 | 0.757188 | 0.411164 | 00:18 | . interp = ClassificationInterpretation.from_learner(learn) . interp.plot_confusion_matrix() . Exporting the model . Now that we trained the model, we can export it and use it for inference. . learn.export() . learn_inf = load_learner(&#39;export.pkl&#39;) . learn_inf.predict(mols[&#39;molimage&#39;][2]) . (&#39;Inactive&#39;, tensor(1), tensor([0.0191, 0.9809])) . Fin .",
            "url": "https://marcossantanaioc.github.io/fiocruzcheminformatics/jupyter/2020/12/04/first.html",
            "relUrl": "/jupyter/2020/12/04/first.html",
            "date": " • Dec 4, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://marcossantanaioc.github.io/fiocruzcheminformatics/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://marcossantanaioc.github.io/fiocruzcheminformatics/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://marcossantanaioc.github.io/fiocruzcheminformatics/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}